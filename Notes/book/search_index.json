[
["index.html", "Intermediate R Workshop Notes Chapter 1 Introduction 1.1 Workshop Schedule", " Intermediate R Workshop Notes Hena R. Ramay 2020-05-26 Chapter 1 Introduction This notebook is created so that the particpants of the workshop can follow along with the instructors. We will constantly update this notebook during the workshop to include answers to the questions asked during the workshop. So Please ask a lot of questions!! 1.1 Workshop Schedule We will try to cover the following material in the course: Day 1 Time Topic 9:00 Introductions and R markdown basics 9:30 Conditionals and Loops 10:45 Functions 13:00 Apply family 14:00 Advanced plotting ggplot2 Day 2 Time Topic 9:00 ggplot continued 10:45 Rmarkdown themes, adding html and custom css styling 14:00 A short project to bring it all together! "],
["rmarkdown.html", "Chapter 2 Rmarkdown 2.1 Set up new R Markdown file 2.2 Knitr Chunk Options", " Chapter 2 Rmarkdown “If I went back to college again, I’d concentrate on two areas: learning to write and to speak before an audience. Nothing in life is more important than the ability to communicate effectively.” – Gerald R. Ford Learning Objectives Learn how to generate reproducible reports that display your code and results. 2.1 Set up new R Markdown file When you perform wet lab experiments, what information do you put in your lab notebook? You probably include the protocol you used to run the experiment, information about the samples and reagents used in the protocol, and at the end you’ll likely include your results (for instance, a picture of a gel). This essentially creates a report of your experiment. You can do the same with your dry lab analyses using a tool called R Markdown. Why would we want to do this? Your method, results, and interpretation are stored in one place If you update your methodology, you can easily update your results with the click of a button, rather than copying and pasting. DONOT cut and paste your code and results into Word or Power Point as Word often introduces hidden characters and it is not good practice to save your code in Word instread of an R script. R Markdown is a fairly simple language you can use to generate reports that incorporate bits of R code along with the output they produce. There are two steps to generating reports with R Markdown and RStudio: Write your code in R Markdown. Assemble your report as either HTML or a PDF using the package rmarkdown. Next, let’s run through the demo R Markdown file to see some of the options. Go up to File -&gt; New File -&gt; R Markdown. A screen will pop up asking us what kind of document we wish to create. Let’s name our demo report “Trial Report” and fill in your name. Ensure that “Document” is highlighted to the left and that “HTML” is chosen. Click “Ok”. Now we have the example R Markdown file open. The first thing you’ll notice at the top is a header which includes your name, the title of the document, the date, and a field called output. This header tells the package rmarkdown some information it might need about your document, including what format you want the final report rendered in. The next thing you’ll notice is white space with some text describing an R Markdown document. White space in this document represents text of the report you would like to display. You can put anything here describing your analysis, results, etc. and it will be recognized as text and not R code. This white space is interpreted as Markdown language, so you can use any of the tricks we learned in the last lesson to make lists, bold certain words, or create headers in your document. In this trial script, you’ll see how some of these markdown elements are used. For example, the word knit is in bolded (using asterisks), and there are code chucks near the bottom that say echo = FALSE. 2.1.1 R Markdown componenets Notice that the file contains three types of content: An (optional) YAML header surrounded by —s R code chunks surrounded by ```s text mixed with simple text formatting In addition to the white space, you’ll gray blocks that have ``` at the top and bottom. These are called chunks. If the start of a chunk has {r} at the end of the ticks, the code will be run and both it and its output will be displayed in the rendered HTML. In your R Markdown, the code will look like: ```r summary(cars) ``` In your final report, the code will look like: summary(cars) Let’s add a new chunk to end this demo document. To do so, either you can enter three backticks in a row, followed by {r}, or you can click on the green Chunksbutton and choseInsert Chunk. Additionally, there’s a keyboard short cut which is ctrl+alt+iwhich will also pop up a chunk in an R Markdown document. In the chunk, let’s just examine the dimensions of the carmdataset: ```{r} dim(cars) ``` You can actually send the code straight from the chunks over to console to be evaluated in two ways. First, you can highlight the code you want to run in the chunk and hit the Run button, which is located in the top right corner of the pane. 2.1.2 Knit R Markdown These are the basics of writing R Markdown, but we still need to generate a report. To do this, click on the button on the top bar that says “Knit HMTL”. This will prompt you to save the file. Go ahead and save this file as Rmarkdown_demo.Rmd in the altmetrics directory. The ending of the file .Rmd indicates that this is an R Markdown file. When you click on this link, you see in the console that RStudio is running and rendering your R Markdown file. What is actually happening is RStudio is running the function render, which is part of the rmarkdown package. There are two things the command render does. First, it converts the R Markdown file to a Markdown file using the command knit from the knitr package (hence why rendering is called knitting). The second step is then the Markdown file is converted to the final file format (HTML, PDF, or Word). The final result is that an HMTL file will pop up where you’ll see the report. You can see the header has been rendered, there are code and results chunks displayed, and even plots are shown right in the report. Also, if you now look in the altmetrics folder, you’ll see an HTML file of the name Rmarkdown_demo.html. When render is run, it saves the current version of the .Rmd file and the generated HTML file in the directory it is stored in. Exercise Create a new project for this workshop. In this project create a new markdown file called rworkshop.Rmd Change the name of author to yours. Click on the settings icon next to the knit button and go to output options. Try different themes and see how it changes you html output. Chose a theme that you like! 2.2 Knitr Chunk Options Learning Objectives Learn how to format chunks in R Markdown to display only the information you want to display. You’ve learned the basics of how to incorporate markdown syntax with code chunks in an R Markdown file. Let’s explore some additional options for making your code chunks appear the way you want them to appear in your reports. There are many ways to customize your chunks and you can explore all of the options by examining the documentation. Here, we’ll introduce you to some of the most useful options that you might use frequently. Chunk output can be customized with knitr options ⧉, arguments set in the {} of a chunk header. Above, we use five arguments: include = FALSE prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks. echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures. message = FALSE prevents messages that are generated by code from appearing in the finished file. warning = FALSE prevents warnings that are generated by code from appearing in the finished. fig.cap = \"...\" adds a caption to graphical results. The first thing you may want to consider is naming your code chunks, which makes degubbing easier, especially if you have a long script. Chunk names must be unique to each chunk. Write the name of your chunk after the {r}, like: {r chunk_name} R Markdown: ```{r chunky_monkey} summary(cars) ``` Rendered: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 You can use RStudio to navigate to chunks based on their names, which can be especially useful as your script gets long. Click on the bottom left bar where it says (Top Level) and you’ll see all of the chunk names in your script appear. Additionally, naming your chunks will be beneficial to identify errors in your code or slow sections when knitting your report. Sometimes you may not want to see the code that produced a particular result in your report. You can have codeblocks in your R Markdown that are evaluated, but the code is not displayed in the final report by including echo=FALSE after the {r chunk_name}. R Markdown: ```{r funky_monkey, echo=FALSE} summary(cars) ``` Rendered: ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Conversely, sometimes you may want to see the code, but not the output once the code is evalutated. To do so, you can include results=\"hide\" after the chunk_name: R Markdown: ```{r brass_monkey, results=\"hide\"} summary(cars) ``` Rendered: summary(cars) Sometimes, you may want to write a report where both the code and the output are suppressed. Why would you want to do that? Perhaps you’re sending a report to a collaborator and you only want them to see the final figures, but not any data manipulation steps in the middle. To include a chunk that is evaluated, but no output is displayed - neither the code nor the results - put include=FALSE after the chunk_name: R Markdown: ```{r brass_section, include=FALSE} summary(cars) ``` Rendered (I swear there’s a chunk after this! It’s just invisible!): There are tons of other options you can include in your chunks: sizing your figures and whether or not to display error or warning messages. As you write reports of your own data analysis, you can look up these options to create a report formatted in the way you want. In addition to code chunks, you may want to include the results of an evaluation in line with regular text. For instance, you may want to describe the data in a paragraph, and include the number of individuals in that paragraph. To do so, you can indicate that a code box should be evaluated as R by including a lowercase r. R Markdown: The _cars_ dataset included in this analysis contains records for `r dim(cars)[1]` cars. Rendered: The _cars_ dataset included in this analysis contains records for 50 cars. Exercise Now that you are familiar with chunks, create a chunk in which you do sum=1+1. Now by searching on the web, how can you re-use this chunk later in your rmd file. "],
["conditionals-and-loops.html", "Chapter 3 Conditionals and Loops 3.1 Setup 3.2 Conditional statements 3.3 Loops", " Chapter 3 Conditionals and Loops 3.1 Setup 1. Download data. We will be using a dataset containing citation and alternative metrics for articles published in the PLOS family of journals between 2003 and 2010. The data set was compiled by Priem et al 2012 (publication). Download the data onto your computer from this dropbox link and move it into a directory on your computer that makes sense. 2. Read in data into R. counts &lt;- read.delim(&quot;data/counts-raw.txt&quot;) 3.2 Conditional statements Decision making is an important part of programming. This can be achieved in R programming using conditional statements such as if and if...else. if The syntax of an if statement is: if (test_expression) { do_this } x &lt;- 5 if (x &gt; 0) { print(&quot;positive number&quot;) } ## [1] &quot;positive number&quot; if…else The syntax of an if…else statement is: if (test_expression) { do_this } else { do_that } The else part is optional and is only evaluated if test_expression is FALSE. It is important that the else word be in the same line as the closing brace of the if statement. x &lt;- 1 if (x &gt; 0){ print(&quot;positive number&quot;) } else { print(&quot;negative number&quot;) } ## [1] &quot;positive number&quot; Nested if…else statements You can have more than two test expressions: if (test_expression1) { statement1 } else if (test_expression2) { statement2 } else { statement4 } x &lt;- 0 if (x &lt; 0) { print(&quot;negative number&quot;) } else if (x &gt; 0) { print(&quot;positive number&quot;) } else { print(&quot;zero&quot;) } ## [1] &quot;zero&quot; EXERCISE 2.1 Write a simple if…else statement to check if 5 is an odd number and if it is print “I am odd”, otherwise print “I am even”. 3.3 Loops Conceptually, a loop is a way to repeat a sequence of instructions under certain conditions. They allow you to automate parts of your code that are in need of repetition. for loop The easiest and most frequently used loop in R is a for loop. Here is a demonstration of using loops. year &lt;- c(2015,2016,2017,2018) for(i in 1:length(year)) { print(year[i]) } ## [1] 2015 ## [1] 2016 ## [1] 2017 ## [1] 2018 for(i in 1:length(year)) { print(paste0(&quot;the year is &quot;,year[i])) } ## [1] &quot;the year is 2015&quot; ## [1] &quot;the year is 2016&quot; ## [1] &quot;the year is 2017&quot; ## [1] &quot;the year is 2018&quot; while loop In contrast to a for lop, while loops are used to loop until a specific conditional statement is no longer true. while (test_expression) { do_this } i &lt;- 1 while (i &lt; 6) { print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 EXERCISE 2.2 Challenging. From the PLOS journal publication data we read into R above, here is a plot showing the impact factor according to the F1000 (Faculty of 1000) versus the number of times the PDF was downloaded. Using this dataset, write a for loop containing an if...else statement to change the f1000Factor column into categorical variable with two levels: high impact and low impact. Do this by translating the following sentence into R code: for every element in the f1000Factor variable, if the value is greater than zero, change it to “high_impact”, otherwise, change it to “low_impact”. Bonus. Create a box plot (like the one below) showing the number of PDF downloads for high versus low impact articles. "],
["functions.html", "Chapter 4 Functions 4.1 Parts of a function 4.2 The principle of encapsulation 4.3 The return statement", " Chapter 4 Functions “Intelligence is the ability to avoid doing work, yet getting the work done.” ― Linus Torvalds Learning Objectives Functions have two parts: arguments and body Functions have their own environment Functions help you repeat code chunks In the last lesson we learnt to write loops to avoid writing the same code multiple time. Now lets learn how to make our code even more efficient and re-use the same code multiple times without copy-paste! 4.1 Parts of a function We’ve already been using built-in R functions: read.csv, mean, length, etc. These functions allow us to run the same routine with different inputs. Let’s explore read.csv further. All functions in R have two parts: the input arguments and the body. We can see the arguments of a function with the args. args(read.csv) function (file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) NULL So when we pass a character vector like \"data/counts-raw.\", this gets assigned to the argument file. All the other arguments have defaults set, so we do not need to assign them a value. After the arguments have been assigned values, then the body of the function is executed. We can view the body of a function with body. body(read.csv) read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...) read.csv is very short. It just calls another function, read.table, using the input file and the default arguments as the arguments passed to read.table. When we define our own functions, we use the syntax below. We list the arguments, separated by commas, within the parentheses. The body follows, contained within curly brackets {}. function_name &lt;- function(args) { body } 4.2 The principle of encapsulation An important feature of functions is the principle of encapsulation: the environment inside the function is distinct from the environment outside the function. In other words, variables defined inside a function are separate from variables defined outside the function. Here’s an small example to demonstrate this idea. The function ex_fun takes two input arguments, x and y. It calculates z and returns its value. ex_fun &lt;- function(x, y) { z &lt;- x - y return(z) } When we run ex_fun, the only thing returned to the global environment is the value that was assigned to z. The variable z itself was only defined in the function environment, and does not exist in the global environment. ex_fun(3, 10) [1] -7 z Error in eval(expr, envir, enclos): object &#39;z&#39; not found 4.2.1 Environments The situation presented above is a simplified version of environments which will serve you well if you treat functions as truly encapsulated. In reality, things are more complicated. For example, if inside a function you have a variable that has not been defined in the function, it will actually search the global environment for this variable. To learn the advanced details, see the chapter Environments in Advanced R by Hadley Wickham. 4.3 The return statement R provides the shortcut of not needing to use return at the end of the function. Instead, the variable on the last line of the body of the function is returned. This is useful for writing very small functions, but in these lessons we will use return to be more explicit about what is happening. Exercise Write your own function called select_first. It should take a vector as input and return the first element of the list. s Now use articleType column from counts dataframe and use it as input to select_first function. Now create a function called ‘select_el’ which takes two arguments, a vector and an index. It should return the value in the index of the vector. For example if I give it a vector x=(10,22,49) and index=2, it should return 22. select_el(x,index) Now add to select_el funciton some code that will spit out an error if the index &gt; length(x). Hint you can use if statement and stop() function. "],
["the-apply-family.html", "Chapter 5 The apply family 5.1 apply() 5.2 lapply() 5.3 sapply() 5.4 vapply() 5.5 Review of ggplot2 basics 5.6 Statistics 5.7 Scales 5.8 Colour palettes 5.9 Faceting 5.10 Themes 5.11 Multiple plots 5.12 Additional Resources", " Chapter 5 The apply family Learning Objectives Learn to use apply family functions in place of loops. Whenever you’re using a for loop, you might want to revise your code and see whether you can use the lapply function instead. Learn all about this intuitive way of applying a function over a list or a vector, and its variants sapply and vapply. 5.1 apply() apply() takes Data frame or matrix as an input and gives output in vector, list or array. apply() Function is primarily used to avoid explicit uses of loop constructs. It is the most basic of all collections can be used over a matrice. This function takes 3 arguments: apply(X, MARGIN, FUN) apply() takes an array or matrix X, a Margin that takes a value 1 for rows or 2 for columns and applies a functoin FUN to it. m1 &lt;- matrix(C&lt;-(1:10),nrow=5, ncol=6) m1 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 6 1 6 1 6 ## [2,] 2 7 2 7 2 7 ## [3,] 3 8 3 8 3 8 ## [4,] 4 9 4 9 4 9 ## [5,] 5 10 5 10 5 10 a_m1 &lt;- apply(m1, 2, sum) a_m1 ## [1] 15 40 15 40 15 40 Exercise Select the columns from count.raw file from pdfDownloadsCount to hmtlDownloadsCount and using the apply function find the mean of each column. 5.2 lapply() Before you go about solving the exercises below, have a look at the documentation of the lapply() function. The Usage section shows the following expression: lapply(X, FUN, ...) To put it generally, lapply takes a vector or list X, and applies the function FUN to each of its members. If FUN requires additional arguments, you pass them after you’ve specified X and FUN (...). The output of lapply() is a list, the same length as X, where each element is the result of applying FUN on the corresponding element of X. Now that you are truly brushing up on your data science skills, let’s revisit some of the most relevant figures in data science history. We’ve compiled a vector of famous mathematicians/statisticians and the year they were born. Up to you to extract some information! 5.2.0.1 Example # The vector pioneers has already been created for you pioneers &lt;- c(&quot;GAUSS:1777&quot;, &quot;BAYES:1702&quot;, &quot;PASCAL:1623&quot;, &quot;PEARSON:1857&quot;) # Split names from birth year to make split_math a list split_math &lt;- strsplit(pioneers, split = &quot;:&quot;) # Convert to lowercase strings: split_low split_low &lt;- lapply(split_math, tolower) # Take a look at the structure of split_low str(split_low) ## List of 4 ## $ : chr [1:2] &quot;gauss&quot; &quot;1777&quot; ## $ : chr [1:2] &quot;bayes&quot; &quot;1702&quot; ## $ : chr [1:2] &quot;pascal&quot; &quot;1623&quot; ## $ : chr [1:2] &quot;pearson&quot; &quot;1857&quot; 5.2.1 Use lapply with your own function You can use lapply() on your own functions as well. You just need to code a new function and make sure it is available in the workspace. After that, you can use the function inside lapply() just as you did with base R functions. We have already created a select_first() function so lets apply it to a Exercise Use lapply on split_low list and use the select_first() function you created. 5.2.2 lapply and anonymous functions Writing your own functions and then using them inside lapply() is quite an accomplishment! But defining functions to use them only once is kind of overkill, isn’t it? That’s why you can use so-called anonymous functions in R. Previously, you learned that functions in R are objects in their own right. This means that they aren’t automatically bound to a name. When you create a function, you can use the assignment operator to give the function a name. It’s perfectly possible, however, to not give the function a name. This is called an anonymous function: # Named function select_first &lt;- function(x) { x[1] } # Use anonymous function inside lapply() lapply(list(1,2,3), function(x) {x[1]}) 5.2.2.1 Example # Transform: use anonymous function inside lapply names &lt;- lapply(split_low, function(x) { x[1] }) 5.2.3 Use lapply with additional arguments In the video, the triple() function was transformed to the multiply() function to allow for a more generic approach. lapply() provides a way to handle functions that require more than one argument, such as the multiply() function: multiply &lt;- function(x, factor) { x * factor } lapply(list(1,2,3), multiply, factor = 3) On the right we’ve included a generic version of the select functions that you’ve coded earlier: select_el(). It takes a vector as its first argument, and an index as its second argument. It returns the vector’s element at the specified index. 5.2.3.1 Example # Generic select function select_el &lt;- function(x, index) { x[index] } # Use lapply() twice on split_low: names and years names &lt;- lapply(split_low, select_el, index = 1) years &lt;- lapply(split_low, select_el, index = 2) 5.3 sapply() You can use sapply() similar to how you used lapply(). sapply is a user-friendly version and wrapper of lapply by default returning a vector, matrix .The first argument of sapply() is the list or vector X over which you want to apply a function, FUN. Potential additional arguments to this function are specified afterwards (...): sapply(X, FUN, ...) 5.3.0.1 Example # Constructing temp variable names &lt;- sapply(split_low, select_el, index = 1) 5.3.1 sapply with your own function Like lapply(), sapply() allows you to use self-defined functions and apply them over a vector or a list: sapply(X, FUN, ...) Here, FUN can be one of R’s built-in functions, but it can also be a function you wrote. This self-written function can be defined before hand, or can be inserted directly as an anonymous function. 5.3.2 sapply with function returning vector In the previous exercises, you’ve seen how sapply() simplifies the list that lapply() would return by turning it into a vector. But what if the function you’re applying over a list or a vector returns a vector of length greater than 1? If you don’t remember from the video, don’t waste more time in the valley of ignorance and head over to the instructions! 5.3.2.1 Example temp=list(c(1,3,4,4,6),c(3,4,6,8,9)) # Create a function that returns min and max of a vector: extremes extremes &lt;- function(x) { c(min = min(x), max = max(x)) } # Apply extremes() over temp with lapply() lapply(temp, extremes) ## [[1]] ## min max ## 1 6 ## ## [[2]] ## min max ## 3 9 # Apply extremes() over temp with sapply() sapply(temp, extremes) ## [,1] [,2] ## min 1 3 ## max 6 9 5.3.3 sapply can’t simplify, now what? It seems like we’ve hit the jackpot with sapply(). On all of the examples so far, sapply() was able to nicely simplify the rather bulky output of lapply(). But, as with life, there are things you can’t simplify. How does sapply() react? We already created a function, below_zero(), that takes a vector of numerical values and returns a vector that only contains the values that are strictly below zero. 5.3.3.1 Example # temp is already prepared for you in the workspace # Definition of below_zero() below_zero &lt;- function(x) { return(x[x &lt; 0]) } # Apply below_zero over temp using lapply(): freezing_l freezing_l &lt;- lapply(temp, below_zero) # Apply below_zero over temp using sapply(): freezing_s freezing_s &lt;- sapply(temp, below_zero) # Are freezing_l and freezing_s identical? identical(freezing_l, freezing_s) ## [1] TRUE 5.4 vapply() Before you get your hands dirty with the third and last apply function that you’ll learn about in this intermediate R course, let’s take a look at its syntax. The function is called vapply(), and it has the following syntax: vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE) Over the elements inside X, the function FUN is applied. The FUN.VALUE argument expects a template for the return argument of this function FUN. USE.NAMES is TRUE by default; in this case vapply() tries to generate a named array, if possible. For the next set of exercises, you’ll be working on the temp list again, that contains 7 numerical vectors of length 5. We also coded a function basics() that takes a vector, and returns a named vector of length 3, containing the minimum, mean and maximum value of the vector respectively. 5.4.0.1 Example # temp is already available in the workspace # Definition of basics() basics &lt;- function(x) { c(min = min(x), mean = mean(x), max = max(x)) } # Apply basics() over temp using vapply() vapply(temp, basics, numeric(3)) ## [,1] [,2] ## min 1.0 3 ## mean 3.6 6 ## max 6.0 9 5.4.0.2 Exercise &lt;br&gt; Use the table() function and one of the apply functions to see how many counts of each year and articleType are available. Explain which function you used and what does the output look like? &lt;/div&gt; &lt;!--chapter:end:05-Apply_family.Rmd--&gt; # Advanced Plotting &quot;The greatest value of a picture is when it forces us to notice what we never expected to see&quot; -John Tukey --- ## Setup **1. Install the `tidyverse` package.** ```r library(tidyverse) ## ── Attaching packages ────────────────────── tidyverse 1.3.0 ── ## ✓ tibble 3.0.1 ✓ dplyr 0.8.5 ## ✓ tidyr 1.0.3 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ✓ purrr 0.3.4 ## ── Conflicts ───────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 2. Filter data. We will be using the publication dataset that we read into R in Chapter 2 as counts. research &lt;- filter(counts, articleType == &quot;Research Article&quot;) 5.5 Review of ggplot2 basics ggplot2 is a plotting package that makes it simple to create complex plots from data in a data frame. Graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots. A plot can be divided into different fundamental parts: Plot = data + aesthetics + geom Required building blocks: data aesthetics - describe how data are mapped to colour, size, shape, location geoms - geometric objects like points, lines, shapes Optional building blocks: facets - describes how panel plots should be constructed stats - statistical transformations like binning, quantiles, smoothing coordinates - describes the system in which the locations of the geoms will be drawn scales - what scale an aesthetic map uses (ex. male = red, female = blue) To build a ggplot, we will use the following basic template that can be used for different types of plots: ggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) + &lt;GEOM_FUNCTION&gt;() Specify which data set to use for the plot using the data argument. Define a “mapping” (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc. Add “geoms” – graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; common ones include: geom_point() for scatter plots, dot plots, etc. geom_boxplot() for boxplots. geom_histogram() for histograms. geom_barplot() for barplots. geom_line() for trend lines, time series, etc. Example: p &lt;- ggplot(research, aes( x = pdfDownloadsCount, y = wosCountThru2011)) + geom_point() p Adding aesthetics: p &lt;- ggplot(research, aes(x = pdfDownloadsCount, y = wosCountThru2011)) + geom_point(aes(color = journal)) p 5.6 Statistics The function geom_smooth() adds a loess curve to the data along with a 95% confidence interval. p &lt;- ggplot(research, aes(x = pdfDownloadsCount, y = wosCountThru2011)) + geom_point(aes(color = journal)) + geom_smooth() p If we move the colour to the base ggplot call, we get loess curves for each level of that factor. p &lt;- ggplot(research, aes(x = pdfDownloadsCount, y = wosCountThru2011, color = journal)) + geom_point() + geom_smooth() p Check the help page for the function geom_smooth() for more information about how the curve is made. For example, to map a linear model onto the plot, you can choose method = \"lm\". p &lt;- ggplot(research, aes(x = pdfDownloadsCount, y = wosCountThru2011, color = journal)) + geom_point() + geom_smooth(method = &quot;lm&quot;) p 5.7 Scales Now let’s look at the relationship between days since published and citation count. p &lt;- ggplot(research, aes(x = daysSincePublished, y = wosCountThru2011)) + geom_point(aes(color= journal)) p It looks like most of the citation counts are close to 0. We can quickly check the distribution of this variable using a qplot. qplot(data = research, x = wosCountThru2011) To control the plot axes, we use variants of the functions scale_x_* and scale_y_*. p &lt;- ggplot(research, aes(x = daysSincePublished, y = wosCountThru2011)) + geom_point(aes(color= journal)) + scale_y_log10() p ## Warning: Transformation introduced infinite values in continuous y-axis How can we fix this? p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1))) + geom_point(aes(color= journal)) p Notice what this fix has done to the way the y-axis is labelled. To manually update the axis label, we can use the scale_y_continuous() function. p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1))) + geom_point(aes(color= journal)) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100, 1000), name = &quot;Citations&quot;) p The scale family of functions can also be used to change the colours. p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1))) + geom_point(aes(color= journal)) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100,1000), name = &quot;Citations&quot;) + scale_colour_manual(values = c(&quot;red&quot;,&quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;purple&quot;, &quot;orange&quot;,&quot;cyan&quot;), name = &quot;Journal&quot;) p library(viridis) ## Loading required package: viridisLite p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1))) + geom_point(aes(color= journal)) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100,1000), name = &quot;Citations&quot;) + scale_colour_manual(values = viridis(7), name = &quot;Journal&quot;) p 5.8 Colour palettes Choosing good colours to aid visualization is not trivial and requires some (or a lot of) thought. A set of colour palettes have been developed for easy use with ggplot2 through a package called RColorBrewer. There are three types of these premade palettes: * Sequential * Diverging * Qualitative library(RColorBrewer) display.brewer.all() Or, you can create your own color palettes using the colorRamp() or colorRampPalette() function. colorRamp() returns a function that takes values between 0 and 1, indicating the extremes of the color palette. colorRampPalette() returns a function that takes integer arguments and returns a vector of colours. colorRamp() cols &lt;- colorRamp(c(&quot;red&quot;, &quot;blue&quot;)) cols(0) ## [,1] [,2] [,3] ## [1,] 255 0 0 cols(0.5) ## [,1] [,2] [,3] ## [1,] 127.5 0 127.5 cols(1) ## [,1] [,2] [,3] ## [1,] 0 0 255 colorRampPalette() cols &lt;- colorRampPalette(c(&quot;red&quot;, &quot;blue&quot;)) cols(2) ## [1] &quot;#FF0000&quot; &quot;#0000FF&quot; cols(10) ## [1] &quot;#FF0000&quot; &quot;#E2001C&quot; &quot;#C60038&quot; &quot;#AA0055&quot; &quot;#8D0071&quot; &quot;#71008D&quot; &quot;#5500AA&quot; ## [8] &quot;#3800C6&quot; &quot;#1C00E2&quot; &quot;#0000FF&quot; 5.9 Faceting There are two functions to control how plots are divided into facets: facet_wrap() and facet_grid(). facet_wrap() p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1), color = journal)) + geom_point() + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100,1000), name = &quot;Citations&quot;) + facet_wrap(~journal) + geom_smooth(color = &quot;black&quot;, method = &quot;lm&quot;) p It is still difficult to see the spread of the data. Try making the points smaller and transparent. p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1), color = journal)) + geom_point(size = 0.5, alpha = 0.5) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100,1000), name = &quot;Citations&quot;) + facet_wrap(~journal) + geom_smooth(color = &quot;black&quot;, method = &quot;lm&quot;) p facet_grid() What about faceting by two variables? For example, let’s say we want to look at the relationship between days since published and citations for low impact versus high impact articles. First, let’s recreate a variable categorizing high and low impact based on the variable f1000Factor. research &lt;- research %&gt;% mutate(impact = cut(f1000Factor, breaks = c(-Inf,1,Inf), labels = c(&quot;low&quot;, &quot;high&quot;))) p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1), color = journal)) + geom_point(size = 0.5, alpha = 0.5) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100,1000), name = &quot;Citations&quot;) + facet_grid(journal~impact) + geom_smooth(color = &quot;black&quot;, method = &quot;lm&quot;) p By default, R will plot each panel on the same axes. You can override this using the option scales, setting it to free_x to vary the scale across rows, scale_y to vary it across columns, or free to vary across both. p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1), color = journal)) + geom_point(size = 0.5, alpha = 0.5) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100,1000), name = &quot;Citations&quot;) + facet_wrap(~journal, scale = &quot;free&quot;) + geom_smooth(color = &quot;black&quot;, method = &quot;lm&quot;) p Exercise 5.6 Use what you’ve learned to generate the plot below. 5.10 Themes In addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme. The ggthemes package provides a wide variety of options (including an Excel 2003 theme). The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes. This is also the place you can customize the text of your plot. p &lt;- ggplot(research, aes(x = daysSincePublished, y = log10(wosCountThru2011 + 1))) + geom_point(aes(color= journal)) + scale_y_continuous(breaks = c(1,2,3), labels = c(10, 100, 1000), name = &quot;Citations&quot;) + theme_bw() + xlab(&quot;Days Since Published&quot;) + theme(axis.title.x = element_text(size = 14, face = &quot;bold&quot;)) p 5.11 Multiple plots There are two useful packages for combining multiple plots: gridExtra and cowplot. gridExtra has two useful functions: grid.arrange() and arrangeGrob(). However, these functions make no attempt at aligning the plot panels; instead, the plots are simply placed into the grid as they are, so the axes are not aligned. If axis alignment is required, the plot_grid() function of the cowplot package is better. We will try using both here. The gridExtra package Let’s say we want to combine the following three plots: plot1 &lt;- ggplot(research, aes(x = journal, fill = journal)) + geom_bar(color = &quot;black&quot;) + theme_bw() plot1 plot2 &lt;- ggplot(research, aes(x = log10(wosCountThru2011 + 1), y = log10(pdfDownloadsCount + 1), color = journal)) + geom_point(size = 0.5, alpha = 0.5) + theme_bw() + geom_smooth() + xlab(&quot;Citations&quot;) + ylab(&quot;Downloads&quot;) + theme(legend.position = &quot;none&quot;) plot2 plot3 &lt;- ggplot(research, aes(x = impact, y = log10(pdfDownloadsCount + 1), fill = journal)) + geom_boxplot() + theme_bw() + ylab(&quot;Downloads&quot;) plot3 To arrange them together, use the grid.arrange() function. library(gridExtra) grid.arrange(plot1, plot2, plot3) To modify how they are arranged, you can use the layout_matrix argument. grid.arrange(plot1, plot2, plot3, ncol = 2, nrow = 2, layout_matrix = rbind(c(1,2), c(3,3))) The cowplot package We can also arrange these plots using the plot_grid() function. library(cowplot) plot_grid(plot1, plot2, plot3) row1 &lt;- plot_grid(plot1, plot2, labels = c(&quot;A&quot;, &quot;B&quot;), nrow = 1) row2 &lt;- plot_grid(plot3, labels = c(&quot;C&quot;), nrow = 1) plot_grid(row1, row2, nrow = 2) 5.11.1 Saving plots The easiest way to save a plot is using the ggsave() function. Exercise 8.1 Using the publication dataset we’ve been using, complete the following tasks. Generate a table containing the mean and standard error of the number of tweets per journal. It should look something like this: ## # A tibble: 7 x 4 ## journal num mean sem ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 pbio 1325 0.0581 0.0202 ## 2 pcbi 1351 0.127 0.0522 ## 3 pgen 1619 0.0655 0.0204 ## 4 pmed 643 0.311 0.188 ## 5 pntd 621 0.0258 0.00906 ## 6 pone 14078 0.493 0.0345 ## 7 ppat 1459 0.0260 0.00881 Use this table to create a bar plot of mean tweets per journal, including standard error. It should look something like this: Hint: you will want to use the function geom_errorbar() to add the error bars. Create a box plot of the number of citations per journal (ie. the variable wosCountThur2011). Colour the journals using the Accent palette from the RColorBrewer package. It should look something like this: Generate a plot that shows the number of downloads over time, coloured by journal. It should look something like this: 5.12 Additional Resources http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html Mailing list: http://groups.google.com/group/ggplot2 Wiki: https://github.com/hadley/ggplot2/wiki Website: http://had.co.nz/ggplot2/ StackOverflow: http://stackoverflow.com/questions/tagged/ggplot Cheatsheet "],
["advanced-rmarkdown.html", "Chapter 6 Advanced Rmarkdown 6.1 YAML options for HTML documents 6.2 Cool stuff in Rmarkdown 6.3 HTML and CSS basics", " Chapter 6 Advanced Rmarkdown So far we have use default settings to create our Rmarkdown documents. Lets prettify our documents!! 6.1 YAML options for HTML documents As we just mentioned before, Markdown was originally designed for HTML output, so it may not be surprising that the HTML format has the richest features among all output formats. We recommend that you read this full section before you learn other output formats, because other formats have several features in common with the HTML document format, and we will not repeat these features in the corresponding sections. To create an HTML document from R Markdown, you specify the html_document output format in the YAML metadata of your document: --- title: first_markdown author: ME ME date: March 22, 2005 output: html_document --- Lets add themes and highlight options title: first_markdown author: ME ME date: March 22, 2005 output: html_document: theme: yeti highlight: kate Now lets add a table of contents title: first_markdown author: ME ME date: March 22, 2005 output: html_document: theme: yeti highlight: kate toc: true toc_float: collapsed: false toc_depth: 4 if you want to hide your code title: first_markdown author: ME ME date: March 22, 2005 output: html_document: theme: yeti highlight: kate toc: true toc_float: collapsed: false toc_depth: 4 code_folding: hide A way to add custom css title: first_markdown author: ME ME date: March 22, 2005 output: html_document: theme: yeti highlight: kate css: styles.css toc: true toc_float: collapsed: false toc_depth: 4 code_folding: hide 6.2 Cool stuff in Rmarkdown ### CHEATSHEET This cheat sheet has all the details on how to add figures, links, bullets, headings and tables in Rmarkdown! ### Making cools tables in Rmarkdown from R code Tables generated from your R code are very useful to share modified output with other users. Simplest tables in markdown can be generated using the kable function but these table are static and to be honest boring! #### A kable table library(knitr) kable(cars) knitr::kable(cars) speed dist 4 2 4 10 7 4 7 22 8 16 9 10 10 18 10 26 10 34 11 17 11 28 12 14 12 20 12 24 12 28 13 26 13 34 13 34 13 46 14 26 14 36 14 60 14 80 15 20 15 26 15 54 16 32 16 40 17 32 17 40 17 50 18 42 18 56 18 76 18 84 19 36 19 46 19 68 20 32 20 48 20 52 20 56 20 64 22 66 23 54 24 70 24 92 24 93 24 120 25 85 #### A D T table library(DT) datatable(cars) library(DT) datatable(cars) #### DT table with download options library(DT) datatable(cars, extensions = &#39;Buttons&#39;, options = list( dom = &#39;Bfrtip&#39;, buttons = c(&#39;copy&#39;, &#39;print&#39;,&#39;csv&#39;, &#39;excel&#39;) ) ) library(DT) datatable(cars, extensions = &#39;Buttons&#39;, options = list( dom = &#39;Bfrtip&#39;, buttons = c(&#39;copy&#39;, &#39;print&#39;,&#39;csv&#39;, &#39;excel&#39;) ) ) 6.2.1 Making tabs in Rmarkdown You can organize content using tabs by applying the .tabset class attribute to headers within a document. This will cause all sub-headers of the header with the .tabset attribute to appear within tabs rather than as standalone sections. For example: ## Quarterly Results {.tabset} ### By Product (tab content) ### By Region (tab content) You can also specify two additional attributes to control the appearance and behavior of the tabs. The .tabset-fade attribute causes the tabs to fade in and out when switching between tabs. The .tabset-pills attribute causes the visual appearance of the tabs to be “pill” rather than traditional tabs. For example: 6.2.2 Rmarkdown to HTML conversion 6.3 HTML and CSS basics HTML, HyperText Markup Language, gives content structure and meaning by defining that content as, for example, headings, paragraphs, or images. CSS, ** Cascading Style Sheets**, is a presentation language created to style the appearance of content—using, for example, fonts or colors. Lets look at the following examples Simple html generated from Rmarkdown Simple html styled by css from themes Simple html styled by custom css ### HTML &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;My First Heading&lt;/h1&gt; &lt;p&gt;My first paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ####Output: My First Heading My first paragraph. You will not have to worry about html too much in Rmarkdown. However, once in a while you might want to add color to some text or other simple things: &lt;p style=&quot;color:tomato&quot;&gt;My first paragraph.&lt;/p&gt; Output My first paragraph. &lt;p style=&quot;color:tomato;font-family:verdana&quot;&gt;My first paragraph.&lt;/p&gt; Output My first paragraph. I use a lot which means adds a single break meaning a extra empty line There are options for highlighting, bold, italic etc To learn more html go to https://www.w3schools.com/default.asp . 6.3.1 CSS CSS stands for Cascading Style Sheets CSS describes how HTML elements are to be displayed on screen, paper, or in other media CSS saves a lot of work. It can control the layout of multiple web pages all at once External stylesheets are stored in CSS files 6.3.1.1 CSS Syntax A CSS rule-set consists of a selector and a declaration block: The selector points to the HTML element you want to style. The declaration block contains one or more declarations separated by semicolons. Each declaration includes a CSS property name and a value, separated by a colon. Multiple CSS declarations are separated with semicolons, and declaration blocks are surrounded by curly braces. p { color: red; text-align: center; } p is a selector in CSS (it points to the HTML element you want to style: ). color is a property, and red is the property value text-align is a property, and center is the property value To learn more visit https://www.w3schools.com/css/css_syntax.asp Exercise Start a new Rmarkdown file for your project. In the same folder, create a styles.css file.In this file write CSS code to change the color of h1 and h2 to one you like. Now link this file to your project Rmarkdown file. "],
["project.html", "Chapter 7 Project 7.1 Setup 7.2 Task 1 7.3 Task 2 7.4 Task 3 7.5 Task 4 7.6 Task 5 7.7 Task 6", " Chapter 7 Project 7.1 Setup Please download the data folder from Dropbox 7.2 Task 1 Create a new R Project for this case study. Create a new Rmd file to complete your project. Change the auther name of the .Rmd file to your name and add today’s date. Read in all the files in the data folder into single dataframe. Hint: Use for loops to read in all the files.Functions that can be helpful : list.files,read_csv,rbind,data.frame(NULL) 7.3 Task 2 Write a function that takes a dataframe as input and if present, converts Monthin to 4 yearly quaters and add an extra column to your dataframe/tibble called Quarters with 4 levels: Q1,Q2,Q3 and, Q4. When Month is Jan-Mar, Quarter = “Q1” When Month is Apr-Jun, Quarter = “Q2” When Month is Jul-Sep, Quarter = “Q3” When Month is Oct-Dec, Quarter = “Q4” Hint: Use mutate and case_when(), %in% and stop() function 7.4 Task 3 Generate a bar plot that shows the number of transactions of each card type per quarter. (The card type is called Factor_C). Place the legend at the top of the plot. Remove the x axis labels and tick marks. Colour the card types using a palette of your choice from the RColorBrewer package. 7.5 Task 4 Use the colorRampPalette() function to generate a colour ramp between any two colours. Plot the distribution (ie. histogram) of Account ID for each quarter. Add a density line. Remove the legend. Plot the density lines only for Account ID for each month on the same plot. 7.6 Task 5 Use the dplyr functions to generate a dataframe containing the proportion of Approved and Declined transactions for each card type. Generate a bar plot showing the proportion for each card type. Flip the coordinates so that each card type is a row. 7.7 Task 6 Generate an html report of all the above tasks using R Markdown. Use this file as a guide. "],
["usefull-links.html", "Chapter 8 Usefull links 8.1 CheatSheets", " Chapter 8 Usefull links 8.1 CheatSheets This is a useful set of cheat sheets that can be handy for you. Importing data rmarkdown ggplot2 Packages not discussed in the workshop but worth a try! forcats Purrr strings These notes are modified from and at some places directly taken from https://jdblischak.github.io/r-intermediate-altmetrics/ "]
]
